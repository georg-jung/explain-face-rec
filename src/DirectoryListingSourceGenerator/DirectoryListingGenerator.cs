// Copyright (c) Georg Jung. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#nullable enable

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.Caching;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace DirectoryListingSourceGenerator;

[Generator]
public class DirectoryListingGenerator : ISourceGenerator
{
    private readonly MemoryCache _cache = new(nameof(DirectoryListingGenerator));

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new DirectoryListingSyntaxReceiver());
    }

    [System.Diagnostics.CodeAnalysis.SuppressMessage("StyleCop.CSharp.LayoutRules", "SA1503:Braces should not be omitted", Justification = "<Ausstehend>")]
    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not DirectoryListingSyntaxReceiver receiver) return;

        foreach (var methodDeclaration in receiver.CandidateMethods)
        {
            var model = context.Compilation.GetSemanticModel(methodDeclaration.SyntaxTree);
            var methodSymbol = model?.GetDeclaredSymbol(methodDeclaration);

            var attributeData = methodSymbol?.GetAttributes()
                .FirstOrDefault(attr => nameof(DirectoryListingAttribute).Equals(attr.AttributeClass?.Name) && attr.ConstructorArguments.Length == 1);

            if (attributeData is null) continue;

            var path = attributeData.ConstructorArguments[0].Value as string;
            if (path is null) continue;

            var returnType = methodDeclaration.ReturnType.ToString();
            string methodSource;

            if (returnType == "string[]")
            {
                methodSource = GenerateStringArrayMethodImplementation(methodSymbol!, methodDeclaration.SyntaxTree.FilePath, path);
            }
            else if (returnType == "IReadOnlyDictionary<string, string[]>")
            {
                methodSource = GenerateDictionaryMethodImplementation(methodSymbol!, methodDeclaration.SyntaxTree.FilePath, path);
            }
            else
            {
                continue;
            }

            context.AddSource($"{methodSymbol!.ContainingType.Name}.{methodSymbol!.Name}.g.cs", SourceText.From(methodSource, Encoding.UTF8));
        }
    }

    private string GenerateMethodImplementation(IMethodSymbol methodSymbol, string collectionInitializerContent, string? returnInstanceType = null)
    {
        var containingType = methodSymbol.ContainingType;
        var namespaceName = containingType.ContainingNamespace.ToDisplayString();
        var className = containingType.Name;
        var methodName = methodSymbol.Name;
        var methodAccessibility = methodSymbol.DeclaredAccessibility.ToString().ToLowerInvariant();
        var staticSymbol = methodSymbol.IsStatic ? "static" : string.Empty;
        var retType = methodSymbol.ReturnType.ToDisplayString();

        return $@"// <auto-generated/>
using System;
using System.Collections.Generic;

namespace {namespaceName}
{{
    partial class {className}
    {{
        {methodAccessibility} {staticSymbol} partial {retType} {methodName}()
        {{
            return new {returnInstanceType ?? retType}
            {{
{collectionInitializerContent}
            }};
        }}
    }}
}}";
    }

    private string GenerateStringArrayMethodImplementation(IMethodSymbol methodSymbol, string classFilePath, string pathArgument)
    {
        var classDir = Path.GetDirectoryName(classFilePath);
        var fullPath = Path.GetFullPath(Path.Combine(classDir, pathArgument));
        var files = GetFilesAtCompileTime(fullPath);
        return GenerateMethodImplementation(methodSymbol, files);
    }

    private string GenerateDictionaryMethodImplementation(IMethodSymbol methodSymbol, string classFilePath, string pathArgument)
    {
        var classDir = Path.GetDirectoryName(classFilePath);
        var fullPath = Path.GetFullPath(Path.Combine(classDir, pathArgument));
        var directoryEntries = GetDirectoryEntriesAtCompileTime(fullPath);
        return GenerateMethodImplementation(methodSymbol, directoryEntries, "Dictionary<string, string[]>");
    }

    private string GetFilesAtCompileTime(string fullPath)
        => GetCached($"Files_{fullPath}", () => GetFilesAtCompileTimeImpl(fullPath));

    private string GetFilesAtCompileTimeImpl(string directory)
    {
        if (Directory.Exists(directory))
        {
            var files = Directory.GetFiles(directory).Select(Path.GetFileName).Select(file => $@"@""{file}""");
            return string.Join(",\n", files);
        }

        return string.Empty;
    }

    private string GetDirectoryEntriesAtCompileTime(string fullPath)
        => GetCached($"Directory_{fullPath}", () => GetDirectoryEntriesAtCompileTimeImpl(fullPath));

    private string GetDirectoryEntriesAtCompileTimeImpl(string directory)
    {
        var directoryData = GetDirectoriesAndFilesAtCompileTime(directory);
        return string.Join(",\n", directoryData.Select(kv => $@"{{ ""{kv.Key}"", new string[] {{ {string.Join(", ", kv.Value.Select(file => $@"@""{file}"""))} }} }}"));
    }

    private Dictionary<string, List<string>> GetDirectoriesAndFilesAtCompileTime(string directory)
    {
        var result = new Dictionary<string, List<string>>();

        if (Directory.Exists(directory))
        {
            var directories = Directory.GetDirectories(directory);

            foreach (var dir in directories)
            {
                var dirName = Path.GetFileName(dir);
                var files = Directory.GetFiles(dir).Select(Path.GetFileName).ToList();
                result[dirName] = files;
            }
        }

        return result;
    }

    private string GetCached(string key, Func<string> factory)
    {
        var cached = _cache.Get(key);
        if (cached is string val)
        {
            return val;
        }

        var result = factory();
        _cache.Add(key, result, DateTimeOffset.Now.AddMinutes(1));
        return result;
    }

    private sealed class DirectoryListingSyntaxReceiver : ISyntaxReceiver
    {
        public List<MethodDeclarationSyntax> CandidateMethods { get; } = new();

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            if (syntaxNode is MethodDeclarationSyntax methodDeclarationSyntax &&
                methodDeclarationSyntax.AttributeLists.Count > 0 &&
                methodDeclarationSyntax.Modifiers.Any(SyntaxKind.PartialKeyword) &&
                (methodDeclarationSyntax.ReturnType.ToString() == "string[]" ||
                 methodDeclarationSyntax.ReturnType.ToString() == "IReadOnlyDictionary<string, string[]>"))
            {
                CandidateMethods.Add(methodDeclarationSyntax);
            }
        }
    }

}
