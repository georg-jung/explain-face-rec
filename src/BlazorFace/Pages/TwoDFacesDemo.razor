@page "/2dDemo"
@layout LegalLayout
@using FaceAiSharp.Abstractions;
@using FaceAiSharp.Extensions;
@using Humanizer;
@using SixLabors.ImageSharp.Drawing.Processing;
@using SixLabors.ImageSharp.PixelFormats;
@using Plotly.Blazor
@using Plotly.Blazor.Traces
@inject IJSRuntime JS
@inject IClock clock;
@inject ObjectPool<IFaceDetector> detectorPool;
@inject ObjectPool<IFaceEmbeddingsGenerator> embedderPool;

<PageTitle>Face Recognition Pipeline</PageTitle>

<div class="container mb-4">
    <p>
        To get started, please upload images that contain one or more human faces.
    </p>

    <div class="mb-3">
        <InputFile multiple OnChange="@LoadFiles" class="@($"form-control {(_uploadNoImage ? "is-invalid" : "")}")" style="max-width: 32rem;" />
        @if (_uploadNoImage)
        {
            <div class="invalid-feedback">The uploaded file could not be read as image.</div>
        }
        @foreach (var tl in _tooLargeFiles)
        {
            <Alert class="mt-3">
                @tl was skipped because it is larger than the maximum supported file size (@MaxUploadSize.Bytes()).
            </Alert>
        }
        @foreach (var tl in _noFaceFiles)
        {
            <Alert class="mt-3">
                @tl was skipped because no face was found.
            </Alert>
        }
    </div>

    <p>
        <MultiChoiceRadio Choices="@(new[] {"2D", "3D"})" @bind-SelectedChoice="@_2dOr3d" @bind-SelectedChoice:after="@ReduceDims" />
    </p>
    <p>
        <MultiChoiceRadio Choices="@(new[] {PCA, UMAP})" @bind-SelectedChoice="@_pcaOrUmap" @bind-SelectedChoice:after="@ReduceDims" />
    </p>
    <p>
        @if (UMAP.Equals(_pcaOrUmap))
        {
            var rangeId = Guid.NewGuid().ToString("n");
            <label for="@rangeId" class="form-label">UMAP Number of neighbors: @_umapNeighbors</label>
            <input @bind="@_umapNeighbors" type="range" class="form-range" min="1" max="100" @bind:event="oninput" id="@rangeId">
        }
    </p>

    <p class="mt-3">
        <button class="btn btn-primary" @onclick="@ReduceDims">Refresh</button>
    </p>

    <PlotlyChart @bind-Config="config" @bind-Layout="layout" @ref="chart" style="height: 60rem; width: 60rem;" />
</div>

@code {
    const int MaxUploadSize = 1024 * 1024 * 10; // 10 MB

    private readonly List<string> _tooLargeFiles = new();
    private readonly List<string> _noFaceFiles = new();
    private bool _uploadNoImage = false;

    private List<byte[]> _alignedFaces = new();
    private List<float[]> _embeddings = new();
    private List<string> _fileNames = new();

    private const string UMAP = "UMAP";
    private const string PCA = "PCA";
    private string _2dOr3d = "2D";
    private string _pcaOrUmap = "PCA";
    private int _umapNeighbors = 15;

    PlotlyChart? chart;
    Config config = new Config();
    Layout layout = new Layout()
        {
            Scene = new[] {
                new Plotly.Blazor.LayoutLib.Scene()
                {
                    XAxis = new()
                    {
                        ShowAxesLabels = false,
                        ShowTickLabels = false,
                        ShowLine = false,
                        ZeroLine = false,
                    },
                    YAxis = new()
                    {
                        ShowAxesLabels = false,
                        ShowTickLabels = false,
                        ShowLine = false,
                        ZeroLine = false,
                    },
                    ZAxis = new()
                    {
                        ShowAxesLabels = false,
                        ShowTickLabels = false,
                        ShowLine = false,
                        ZeroLine = false,
                    },
                },
            },
            XAxis = new[]
            {
                new Plotly.Blazor.LayoutLib.XAxis()
                {
                    ShowTickLabels = false,
                    ShowLine = false,
                    ZeroLine = false,
                }
            },
            YAxis = new[]
                {
                new Plotly.Blazor.LayoutLib.YAxis()
                {
                    ScaleAnchor = "x",
                    ShowTickLabels = false,
                    ShowLine = false,
                    ZeroLine = false,
                }
            },
            ShowLegend = false,
        };

    private async void LoadFiles(InputFileChangeEventArgs e)
    {
        _tooLargeFiles.Clear();
        _noFaceFiles.Clear();
        var files = e.TryOpenMultiple(1000, MaxUploadSize);

        foreach (var (content, name, tooLarge) in files)
        {
            if (content is null)
            {
                _tooLargeFiles.Add(name);
                continue;
            }
            await LoadFile(content, name);
        }
    }

    private async Task LoadFile(System.IO.Stream file, string fileName)
    {
        using var img = await file.TryOpenImage();
        if (img == null)
        {
            _uploadNoImage = true;
            StateHasChanged();
            return;
        }

        var det = detectorPool.Get();
        var embGen = embedderPool.Get();
        try
        {
            var detection = det.Detect(img);
            if (detection.Count == 0)
            {
                _noFaceFiles.Add(fileName);
                StateHasChanged();
                return;
            }

            var first = detection.First();
            var lmrks = first.Landmarks ?? throw new InvalidOperationException("Face detection with landmarks is required.");

            FaceAiSharp.ArcFaceEmbeddingsGenerator.AlignUsingFacialLandmarks(img, first.Landmarks);
            var emb = embGen.Generate(img);
            _embeddings.Add(emb);

            using var ms = new MemoryStream();
            img.SaveAsJpeg(ms);
            _alignedFaces.Add(ms.ToArray());

            _fileNames.Add(fileName);

            await ReduceDims();
        }
        finally
        {
            detectorPool.Return(det);
            embedderPool.Return(embGen);
        }
    }

    private async Task ReduceDims()
    {
        if (_embeddings.Count < 2) return;
        var is2d = "2D".Equals(_2dOr3d, StringComparison.Ordinal);
        var isPca = PCA.Equals(_pcaOrUmap, StringComparison.Ordinal);

        float[][] Umap() {
            var umap = new UMAP.Umap(dimensions: is2d ? 2 : 3, numberOfNeighbors: _umapNeighbors);
            var numEpochs = umap.InitializeFit(_embeddings.ToArray());
            for (var i = 0; i < numEpochs; i++)
                umap.Step();

            return umap.GetEmbedding();
        }

        float[][] Pca()
        {
            var embs = _embeddings.Select(arr => Array.ConvertAll(arr, x => (double)x)).ToArray();
            var pca = new Accord.Statistics.Analysis.PrincipalComponentAnalysis();
            pca.NumberOfOutputs = is2d ? 2 : 3;
            pca.Learn(embs);
            return pca.Transform(embs).Select(arr => Array.ConvertAll(arr, x => (float)x)).ToArray();
        }

        var embeddings = isPca ? Pca() : Umap();

        ITrace trace = is2d switch
        {
            true => new Scatter
                {
                    Mode = Plotly.Blazor.Traces.ScatterLib.ModeFlag.Markers,
                    X = embeddings.Select(x => x[0]).Cast<object>().ToList(),
                    Y = embeddings.Select(x => x[1]).Cast<object>().ToList(),
                    TextArray = _fileNames.ToList(),
                    HoverInfo = Plotly.Blazor.Traces.ScatterLib.HoverInfoFlag.Text,
                },
            false => new Scatter3D
                {
                    Mode = Plotly.Blazor.Traces.Scatter3DLib.ModeFlag.Markers,
                    X = embeddings.Select(x => x[0]).Cast<object>().ToList(),
                    Y = embeddings.Select(x => x[1]).Cast<object>().ToList(),
                    Z = embeddings.Select(x => x[2]).Cast<object>().ToList(),
                    TextArray = _fileNames.ToList(),
                    HoverInfo = Plotly.Blazor.Traces.Scatter3DLib.HoverInfoFlag.Text,
                },
        };

        await chart!.Clear();
        await chart!.AddTrace(trace);
        StateHasChanged();
    }
}
