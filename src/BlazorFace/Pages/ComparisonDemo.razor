@page "/ComparisonDemo"
@layout LegalLayout
@using FaceAiSharp.Abstractions;
@using FaceAiSharp.Extensions;
@using Humanizer;
@using SixLabors.ImageSharp.Drawing.Processing;
@using SixLabors.ImageSharp.PixelFormats;
@using UMapx.Imaging;
@using UMapx.Visualization;
@inject IJSRuntime JS
@inject IClock clock;
@inject ObjectPool<IFaceDetector> detectorPool;
@inject ObjectPool<IFaceEmbeddingsGenerator> embedderPool;

<PageTitle>Face Comparison</PageTitle>

<div class="container">
    <p>
        To get started, please upload two images that contain one or more human faces.
    </p>

    <div class="mb-3">
        <InputFile OnChange="@LoadFiles1" class="@($"form-control {(_upload1result.UploadWasTooLarge || _upload1result.ImageCouldNotBeRead ? "is-invalid" : "")}")" style="max-width: 32rem;" />
        @if (_upload1result.UploadWasTooLarge)
        {
            <div class="invalid-feedback">Maximum supported file size is @MaxUploadSize.Bytes().</div>
        }
        @if (_upload1result.ImageCouldNotBeRead)
        {
            <div class="invalid-feedback">The uploaded file could not be read as image.</div>
        }
    </div>
    <div class="mb-3">
        <InputFile OnChange="@LoadFiles2" class="@($"form-control {(_upload2result.UploadWasTooLarge || _upload2result.ImageCouldNotBeRead ? "is-invalid" : "")}")" style="max-width: 32rem;" />
        @if (_upload2result.UploadWasTooLarge)
        {
            <div class="invalid-feedback">Maximum supported file size is @MaxUploadSize.Bytes().</div>
        }
        @if (_upload2result.ImageCouldNotBeRead)
        {
            <div class="invalid-feedback">The uploaded file could not be read as image.</div>
        }
    </div>

    <h2 class="mt-4">1. Embeddings 1</h2>

    @if (_upload1result.NoFaceFound)
    {
        <div class="alert alert-warning" role="alert">
            No face could be found in the image you uploaded.
        </div>
    }

    <p>
        <img id="img1" class="mw-100" />
    </p>

    @if (_upload1result.Embeddings != null)
    {
        <BlazorFace.Components.ExpandableEmbeddings Embeddings="@string.Join("\n", _upload1result.Embeddings)" />
    }

    <h2 class="mt-4">2. Embeddings 2</h2>

    @if (_upload2result.NoFaceFound)
    {
        <div class="alert alert-warning" role="alert">
            No face could be found in the image you uploaded.
        </div>
    }

    <p>
        <img id="img2" class="mw-100" />
    </p>

    @if (_upload2result.Embeddings != null)
    {
        <BlazorFace.Components.ExpandableEmbeddings Embeddings="@string.Join("\n", _upload2result.Embeddings)" />
    }

    <h2 class="mt-4">3. Measures</h2>

    @if (_dotProd >= 0.42)
    {
        <div class="alert alert-success" role="alert">
            Both pictures show the same person.
        </div>
    }
    else if (_dotProd > 0.28 && _dotProd < 0.42)
    {
        <div class="alert alert-warning" role="alert">
            Hard to tell if the pictures show the same person.
        </div>
    }
    else if (_dotProd <= 0.28)
    {
        <div class="alert alert-danger" role="alert">
            These are two different people.
        </div>
    }

    <ul>
        <li>Euclidean Distance:   @_euclideanDist</li>
        <li>Euclidean Similarity: @_euclideanSimilarity</li>
        <li>Cosine Distance:      @_cosineDist</li>
        <li>Cosine Similarity:    @_cosineSimilarity</li>
        <li>
            Dot Product:          @_dotProd
            <ul>
                <li>If the dot product's value is larger than a defined threshold, the faces are considered to belong to the same person.</li>
                <li>Depending on the kind of statistical error you prefer, reasonable threshold values might be anywhere between 0.25 and 0.5.</li>
            </ul>
        </li>
    </ul>

    <button class="btn btn-primary" @onclick="Clear">Clear</button>
</div>

@code {
    const int MaxUploadSize = 1024 * 1024 * 10; // 10 MB

    private UploadResult _upload1result;
    private UploadResult _upload2result;
    private float? _euclideanDist;
    private float? _euclideanSimilarity;
    private float? _cosineDist;
    private float? _cosineSimilarity;
    private float? _dotProd;

    private async Task Clear()
    {
        _upload1result = _upload2result = default;
        _euclideanDist = _euclideanSimilarity = null;
        _cosineDist = _cosineSimilarity = null;
        _dotProd = null;
        await JS.ClearImage("img1");
        await JS.ClearImage("img2");
        StateHasChanged();
    }

    private async void LoadFiles1(InputFileChangeEventArgs e)
    {
        _upload1result = await LoadFiles(e, "img1");
        TryCalcMeasures();
        StateHasChanged();
    }

    private async void LoadFiles2(InputFileChangeEventArgs e)
    {
        _upload2result = await LoadFiles(e, "img2");
        TryCalcMeasures();
        StateHasChanged();
    }

    private void TryCalcMeasures()
    {
        var (e1, e2) = (_upload1result.Embeddings, _upload2result.Embeddings);
        if (e1 == null || e2 == null) return;

        _euclideanDist = e1.EuclideanDistance(e2);
        _euclideanSimilarity = e1.EuclideanSimilarity(e2);
        _cosineDist = e1.CosineDistance(e2);
        _cosineSimilarity = e1.CosineSimilarity(e2);
        _dotProd = e1.Dot(e2);
    }

    private async Task<UploadResult> LoadFiles(InputFileChangeEventArgs e, string imgId)
    {
        var start = clock.GetCurrentInstant();
        using var file = e.TryOpen(MaxUploadSize, out var ulTooLarge);
        if (file == null) return new(null, UploadWasTooLarge: ulTooLarge);

        using var img = await file.TryOpenImage();
        if (img == null) return new(null, ImageCouldNotBeRead: true);

        var det = detectorPool.Get();
        var embGen = embedderPool.Get();
        try
        {
            var detection = det.Detect(img);
            var firstFace = detection.FirstOrDefault();
            if (firstFace.Landmarks is null)
            {
                return new(null, NoFaceFound: true);
            }

            var angle = det.GetFaceAlignmentAngle(firstFace.Landmarks);
            img.CropAlignedDestructive(Rectangle.Round(firstFace.Box), angle);

            var embeddings = embGen.Generate(img);
            await JS.SetImageStream(img, imgId);
            return new(embeddings);
        }
        finally
        {
            detectorPool.Return(det);
            embedderPool.Return(embGen);
        }
    }

    private readonly record struct UploadResult(float[]? Embeddings, bool UploadWasTooLarge = false, bool NoFaceFound = false, bool ImageCouldNotBeRead = false);
}
