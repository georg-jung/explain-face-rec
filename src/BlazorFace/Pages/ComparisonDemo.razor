@page "/ComparisonDemo"
@layout LegalLayout
@using FaceAiSharp.Abstractions;
@using FaceAiSharp.Extensions;
@using Humanizer;
@using SixLabors.ImageSharp.Drawing.Processing;
@using SixLabors.ImageSharp.PixelFormats;
@using UMapx.Imaging;
@using UMapx.Visualization;
@inject IJSRuntime JS
@inject IClock clock;
@inject ObjectPool<IFaceDetector> detectorPool;
@inject ObjectPool<IFaceEmbeddingsGenerator> embedderPool;

<PageTitle>Face Comparison</PageTitle>

<div class="container">
    <p>
        To get started, please upload two images that contain one or more human faces.
    </p>

    <div class="mb-3">
        <InputFile OnChange="@LoadFiles1" class="@($"form-control {(_upload1WasTooLarge ? "is-invalid" : "")}")" style="max-width: 32rem;" />
        @if (_upload1WasTooLarge)
        {
            <div class="invalid-feedback">Maximum supported file size is @MaxUploadSize.Bytes().</div>
        }
    </div>
    <div class="mb-3">
        <InputFile OnChange="@LoadFiles2" class="@($"form-control {(_upload2WasTooLarge ? "is-invalid" : "")}")" style="max-width: 32rem;" />
        @if (_upload2WasTooLarge)
        {
            <div class="invalid-feedback">Maximum supported file size is @MaxUploadSize.Bytes().</div>
        }
    </div>

    <h2 class="mt-4">1. Embeddings 1</h2>

    @if (_upload1NoFace)
    {
        <div class="alert alert-warning" role="alert">
            No face could be found in the image you uploaded.
        </div>
    }

    <p>
        <img id="img1" class="mw-100" />
    </p>

    @if (_embeddings1 != null)
    {
        <BlazorFace.Components.ExpandableEmbeddings Embeddings="@string.Join("\n", _embeddings1)" />
    }

    <h2 class="mt-4">2. Embeddings 2</h2>

    @if (_upload2NoFace)
    {
        <div class="alert alert-warning" role="alert">
            No face could be found in the image you uploaded.
        </div>
    }

    <p>
        <img id="img2" class="mw-100" />
    </p>

    @if (_embeddings2 != null)
    {
        <BlazorFace.Components.ExpandableEmbeddings Embeddings="@string.Join("\n", _embeddings2)" />
    }

    <h2 class="mt-4">3. Measures</h2>

    <ul>
        <li>Euclidean Distance:   @_euclideanDist</li>
        <li>Euclidean Similarity: @_euclideanSimilarity</li>
        <li>Cosine Distance:      @_cosineDist</li>
        <li>Cosine Similarity:    @_cosineSimilarity</li>
    </ul>

    <button class="btn btn-primary" @onclick="Clear">Clear</button>
</div>

@code {
    const int MaxUploadSize = 1024 * 1024 * 10; // 10 MB

    private bool _upload1WasTooLarge = false;
    private bool _upload2WasTooLarge = false;
    private bool _upload1NoFace = false;
    private bool _upload2NoFace = false;
    private float[]? _embeddings1;
    private float[]? _embeddings2;
    private float? _euclideanDist;
    private float? _euclideanSimilarity;
    private float? _cosineDist;
    private float? _cosineSimilarity;

    Stream? TryOpen(InputFileChangeEventArgs e, out bool uploadWasTooLarge)
    {
        try
        {
            var s = e.File.OpenReadStream(MaxUploadSize);
            uploadWasTooLarge = false;
            return s;
        }
        catch (IOException ex)
          when (ex.Message.Contains("byte", StringComparison.OrdinalIgnoreCase))
        {
            uploadWasTooLarge = true;
            return null;
        }
    }

    private async Task Clear()
    {
        _embeddings1 = _embeddings2 = null;
        _euclideanDist = _euclideanSimilarity = null;
        _cosineDist = _cosineSimilarity = null;
        await JS.ClearImage("img1");
        await JS.ClearImage("img2");
        StateHasChanged();
    }

    private async void LoadFiles1(InputFileChangeEventArgs e)
    {
        (_embeddings1, _upload1WasTooLarge, _upload1NoFace) = await LoadFiles(e, "img1");
        TryCalcMeasures();
        StateHasChanged();
    }

    private async void LoadFiles2(InputFileChangeEventArgs e)
    {
        (_embeddings2, _upload2WasTooLarge, _upload2NoFace) = await LoadFiles(e, "img2");
        TryCalcMeasures();
        StateHasChanged();
    }

    private void TryCalcMeasures()
    {
        if (_embeddings1 == null || _embeddings2 == null) return;

        _euclideanDist = _embeddings1.EuclideanDistance(_embeddings2);
        _euclideanSimilarity = _embeddings1.EuclideanSimilarity(_embeddings2);
        _cosineDist = _embeddings1.CosineDistance(_embeddings2);
        _cosineSimilarity = _embeddings1.CosineSimilarity(_embeddings2);
    }

    private async Task<(float[]? Embeddings, bool UploadWasTooLarge, bool NoFaceFound)> LoadFiles(InputFileChangeEventArgs e, string imgId)
    {
        var start = clock.GetCurrentInstant();
        using var file = TryOpen(e, out var ulTooLarge);
        if (file == null) return (null, ulTooLarge, false);

        using var img = await Image.LoadAsync<Rgb24>(file);

        var det = detectorPool.Get();
        var embGen = embedderPool.Get();
        try
        {
            var detection = det.Detect(img);
            var firstFace = detection.FirstOrDefault();
            if (firstFace.Landmarks is null)
            {
                return (null, false, true);
            }

            var angle = det.GetFaceAlignmentAngle(firstFace.Landmarks);
            using var imgFirstFaceAligned = img.CropAligned(Rectangle.Round(firstFace.Box), angle);

            var embeddings = embGen.Generate(imgFirstFaceAligned);
            await JS.SetImageStream(imgFirstFaceAligned, imgId);
            return (embeddings, false, false);
        }
        finally
        {
            detectorPool.Return(det);
            embedderPool.Return(embGen);
        }
    }
}
