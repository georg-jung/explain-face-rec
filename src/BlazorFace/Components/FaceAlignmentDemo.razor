@inherits ChooseSingleImageBase

@using FaceAiSharp.Abstractions;
@using FaceAiSharp.Extensions;
@using FaceAiSharp;
@using SixLabors.ImageSharp.Drawing.Processing;
@using SixLabors.ImageSharp.PixelFormats;
@using BlazorFace.Components

@inject IJSRuntime JS
@inject ObjectPool<IFaceDetector> detectorPool
@inject ObjectPool<IFaceEmbeddingsGenerator> embedderPool

@{
    base.BuildRenderTree(__builder);
}

<div class="d-flex flex-row justify-content-center mt-3 @(IsProcessing ? "d-none" : "")">
    <p>
        Expected landmark positions:
        <MultiChoiceRadio Class="ms-2" Choices="@(new[] {Yellow, Red, Blue, Green, Hide})" @bind-SelectedChoice="@_overlayColorString" />
    </p>
</div>

<style>
    .img-overlay-wrap {
        position: relative;
        display: inline-block; /* shrinks container to image size */
        transition: transform 150ms ease-in-out;
    }

        .img-overlay-wrap .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 4;
            pointer-events: none;
        }
</style>

<div class="d-flex flex-row justify-content-center align-items-center mt-3 restrict-child-image-size">
    <div class="img-overlay-wrap">
        <ImageCompareViewer LeftLabel="Unaligned" RightLabel="Aligned">
            <img id="@imgUnalignedId" />
            <img id="@imgAlignedId" />
        </ImageCompareViewer>
        <svg class="overlay" style="color: #@(_overlayColor.ToHex())">
            <use xlink:href='/media/deepinsight-targetpoints.opt.svg#img' href="/media/deepinsight-targetpoints.opt.svg#img"></use>
        </svg>
    </div>
</div>

@code {
    private const string Yellow = nameof(Yellow);
    private const string Red = nameof(Red);
    private const string Blue = nameof(Blue);
    private const string Green = nameof(Green);
    private const string Hide = nameof(Hide);

    private string _overlayColorString = Yellow;
    private Color _overlayColor => _overlayColorString switch
    {
        Red => Color.Red,
        Yellow => Color.Yellow,
        Blue => Color.DodgerBlue,
        Green => Color.LimeGreen,
        _ => Color.Transparent,
    };

    private readonly string imgUnalignedId = Guid.NewGuid().ToString("n");
    private readonly string imgAlignedId = Guid.NewGuid().ToString("n");

    protected override async Task Clear()
    {
        await base.Clear();
        await JS.ClearImage(imgUnalignedId);
    }

    protected override async Task<string?> OnImageLoadedAsync(Image<Rgb24> image)
    {
#if ANDROID
        return await Task.Run(() => OnImageLoadedAsyncImpl(image));
#else
        return await OnImageLoadedAsyncImpl(image);
#endif
    }

    private async Task<string?> OnImageLoadedAsyncImpl(Image<Rgb24> image)
    {
        var det = detectorPool.Get();
        var emb = embedderPool.Get();

        try
        {
            var detections = det.Detect(image);
            if (detections.Count == 0)
            {
                return "No faces could be found in this image.";
            }

            var first = detections.FirstOrDefault();
            if (first.Landmarks is null || first.Landmarks.Count == 0)
            {
                throw new InvalidOperationException("Landmarks are required.");
            }

            using var unaligned = image.Extract(Rectangle.Round(first.Box).GetMinimumSupersetSquare(), 450, true);

            ArcFaceEmbeddingsGenerator.AlignUsingFacialLandmarks(image, first.Landmarks, 450);

            await InvokeAsync(async () =>
            {
                await JS.SetImageStream(unaligned, imgUnalignedId);
                await JS.SetImageStream(image, imgAlignedId);
                StateHasChanged();
            });

            return null;
        }
        finally
        {
            embedderPool.Return(emb);
            detectorPool.Return(det);
        }
    }
}
